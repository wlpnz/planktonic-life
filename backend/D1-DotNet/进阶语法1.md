### 泛型
#### 定义
泛型(generic)是专门处理多段代码在不同的数据类型上执行相同的指令的情况而设计的。
利用泛型的特性可以定义泛型类、泛型方法、泛型接口、泛型委托。
定义： 用占位符 T(或其他大写字母)代替实际数据类型，若定义方法，在方法名后加上<T>，如GetClassName<T>;
若是泛型类，则在类名后加上<T>，如BaseModel<T>
同理，还有泛型接口、泛型委托，如IData<T>、CustHandler<int, string>。
```C#
//泛型方法
public static string GetClassName<E>(E t) 
{
    return t.GetType().Name;
}
//泛型类
internal class BaseModel<T>
{
    public static void ShowInfo(T t)
    {
        Console.WriteLine(t);
    }
}
//泛型接口
public interface IData<T>
{
    void ShowInfo(T t);
}
//泛型委托

```
#### 泛型约束
泛型定义中，有时有**where**子句，用于指定对用作泛型类型、方法、委托或本地函数中类型参数的约束。
泛型约束包含接口、基类、引用类型约束、值类型约束和无参构造函数约束。
泛型约束，简言之，就是**限定类型的范围**。
约束规则：

1. 可以同时使用一个以上的约束
2. 值类型约束与引用类型约束不能同时使用
3. 引用类型约束不能与基类约束同时使用
4. 如果有基类约束，还有其他约束，基类约束必须在最前面
5. 如果同时使用多个约束，**如果有new(),它必须是最后一个**
##### 值类型约束
```
//值类型的约束 where T:struct限定类型参数的实际类型不能是引用类型
public static T ToType<T>(string str) where T : struct
{
    return (T)Convert.ChangeType(str, typeof(T));
}
```
##### 引用类型约束
```
//引用类型约束 where T:class
public class Record<T> where T : class
{
    public List<T> list = new List<T>();
    //添加记录
    public void AddRecord(T t)
    {
        list.Add(t);
    }
}
```
##### 基类约束
```
// T 必须是基类People或其子类
public static void ShowInfo<T>(T t) where T : People
{
    t.ShowInfo();
}
```
##### 接口约束
```
//接口约束 where T : IData T的实际类型必须实现了IData接口
public static void ShowData<T>(T t) where T : IData<string>
{
    t.ShowInfo("string");
}
```
##### 无参构造函数约束
```
//无参构造函数约束 可以在方法体内部new一个新的泛型对象
//注意：new()必须是最后一个
public static T CreateObj<T>() where T : new()
{
    return new T();
}
```
#### 常见集合类型
##### ArrayList
使用大小会根据需要动态增加的数组来实现IList接口的集合。是动态数组，可以动态的增加和减少元素，但使用中会有性能损耗
因为它的Add方法可以添加任意一个类型的项，可以是int/double,f1ot,.,甚至可以是一个引用类型，所以在使用中对于值类型的存取会
有装箱与拆箱的操作，会产生性能损耗，所以不建议使用这个集合类型，建议使用Lst<T>类型。
```
ArrayList arrList new ArrayList();
arrList.Add(12);
arrList.Add(35.6);
arrList.Add(new IncomeInfo(){IncomeId = 1,IncomeName ="领工资"}
arrList.RemoveAt(1);
int ival=Convert.ToInt32(arrList[0]);//拆箱
```
##### List
一个泛型的集合类型，可通过索引访问的对象的强类型列表，提供用于对列表进行搜索、排序和操作的方法。
它是一个强类型集合，是类型安全的。也是根据需要动态添加或移除其中的项，用于存储不固定数目的一组信息。
lst列表集合操作Add/Insert/AddRange/Remove/RemoveAt/ContainsFind/FindIndex/ndexof/Sort/Reverse/Clear…
```
List<int> ids = new List<int>();// 存储一组int类型的集合
ids.Add(101);//添加到列表尾部
ids.Add(102);
ids.AddRange(new int[] { 103, 104, 105, 106 });//添加多个到末尾
ids.Remove(103);//移除指定元秦
ids.RemoveAt(2);//移除第3个元素
bool b1 = ids.Contains(105);//判断某个元素是否存在
int newId = ids.Find(item => item > 103);//查找符合条件的项 存在返回匹配的第一项，不符合返回0
int index = ids.IndexOf(105);//获取指定元素的索引 没有找到返回-1 找到返回相应索引
List<int> newList = ids.Where(id => id > 103).ToList();//按条件筛选
ids.Sort();//排序
ids.Reverse();//反转
Console.ReadKey();
```
##### Dictionary<TKey, TValue>
表示键和值的集合。它也是一个泛型集合类，强类型集合，类型安全的。
Dictionary<T,V>类型提供从一组键到一组值的映射。每次对字典的添加都包含一个值和与其关联的键。使用键检索值的速度非常快。
键必须是唯一的而值不需要唯一的。
键和值都是类型参数，其实际类型可以是任何类型（比如：string,int,自定义类型，等等）。
键值对操作：Add/遍历/根据键取对应的值。
```
Dictionary<int, string> list = new Dictionary<int, string>();
list.Add(101, "收入1");
list.Add(102, "收入2");
list.Add(103, "收入3");
List<int> itemIds = new List<int>();
foreach (KeyValuePair<int, string> item in list) 
{
    Console.WriteLine($"{item.Key} < === > {item.Value}");
}
foreach (int key in list.Keys)
{
    Console.Write($"{list[key]} \t");
}
```
### 反射
#### 反射的定义
反射一一程序可以**访问、检测和修改**它本身状态或行为的一种能力。反射是.NET中的重要机制。
反射中提供了用来描述**程序集、模块和类型**的对象，可以使用反射**动态地创建类型的实例**，并将类型绑定到现有对象，或者从现有对象中获取类型，然后调用其方法或访问其字段和属性。如果代码中使用了特性，也可以利用反射来访问它们。
通过反射，可以在运行时获得程序或程序集中每一个类型（包括类、结构、委托、接口和枚举等）的成员和成员的信息，即元数据。有了反射，即可对每一个类型了如指掌。
反射用到的类：System.Type、System.Relection.Assembly、Activator
Type:类的信息类，可以**获取类的相关信息**（构造函数、方法、字段、属性、事件等）》
Assembly:程序集类，**加载其他程序集**，加载后能用Type获取其中某类的信息
Activator:快速实例化对象的类，可将Type对象实例化为相应类型的对象
#### 反射的用途
C#中反射具有以下用途：

- 在运行时查看类型元数据
- 检查装配中的各种类型并动态实例化这些类型
- 运行时动态读写对象的属性值，调用方法、动态加载程序集
- 运行时访问应用的特性
#### 动态实例化
类型实例化，除了可以直接使用类型实例化创建对象以外，当不能直接引用类型时，还可以通过反射技术来动态实例化。
```
string fullName = "net_consoleApp_2.Models.Student";//完整名称
Type itemType = Type.GetType(fullName);//ItemIrfol的Type对象
 
//创建对象实例
object itemInfo = Activator.CreateInstance(itemType);//调用无参构造函数来动态创建
Student item1 = (Student)itemInfo;
item1.ShowInfo();

//typeof(type) 返回的对象就是Type类型
Student item2 = (Student)Activator.CreateInstance(typeof(Student));
item2.ShowInfo();
```
#### 元数据
```
//查看元数据
ItemInfo item = new ItemInfo()
{
  Id = 101,
  ItemType = "收入",
  ItemName = "银行转账"
};
item.remark = "通过银行转账获取收入";
Type typeItem = typeof(ItemInfo);//类型对象
//1.属性
PropertyInfo[] properties = typeItem.GetProperties();//所有公开的属性数组
//不通过直接代码访问，读取对象中的属性值：  属性名--属性值
foreach (PropertyInfo property in properties) {
   Console.WriteLine(property.Name+"："+property.GetValue(item).ToString());
}

//property.Name  获取属性名称   property.GetValue(obj) 获取obj对象中property属性的值
//获取ItemType属性的值
PropertyInfo itemTypeProp = typeItem.GetProperty("ItemType");//获取ItemType属性
string itemType = itemTypeProp.GetValue(item).ToString();//获取ItemType属性的值

//修改属性值
item.ItemName = "工资发放";//直接代码修改
//通过属性对象来修改ItemName的属性值
typeItem.GetProperty("ItemName").SetValue(item, "朋友还钱");

//2.字段
//公有字段
var fileds=  typeItem.GetFields();
FieldInfo fRemark = typeItem.GetField("remark");//指定名称的字段
fRemark.SetValue(item, "通过工资发放");//修改字段的值
string remark = fRemark.GetValue(item).ToString();//获取字段的值
Console.WriteLine( "字段remark:"+remark);

FieldInfo fType= typeItem.GetField("itemType", BindingFlags.NonPublic | BindingFlags.Instance);//获取私有字段
string typeStr = fType.GetValue(item).ToString();//获取字段的值

//3.方法
string strInfo=  item.GetItemInfo();//直接调用

//反射方式调用
//获取方法
MethodInfo[] methods=  typeItem.GetMethods();
foreach( MethodInfo method in methods )
{
    Console.WriteLine(method.Name);//方法名
}
//获取指定的方法
MethodInfo getItemInfo = typeItem.GetMethod("GetItemInfo");
//调用方法  无参方法  没有参数--null
string  reStr= getItemInfo.Invoke(item,null).ToString();

MethodInfo getCount = typeItem.GetMethod("GetCount");
//调用静态方法  第一个参数：null 
int reCount = (int)getCount.Invoke(null, null);

Console.WriteLine(reStr);
//获取带一个参数的方法
MethodInfo setCount = typeItem.GetMethod("SetCount", new Type[] { typeof(int) });
int count = 5;
//调用一个参数的方法
setCount.Invoke(item, new object[] { count });
Console.WriteLine("数量："+ItemInfo.count);
setCount.Invoke(item, new object[] { 6 });
Console.WriteLine("数量：" + ItemInfo.count);

ExpendInfo expendInfo = new ExpendInfo();
Type expendType= typeof(ExpendInfo);
//获取带一个参数的方法
MethodInfo addAmount = expendType.GetMethod("AddAmount", new Type[] { typeof(decimal),typeof(decimal) });
decimal amount1 = 300m, amount2 = 50m;
//调用两个参数的方法
decimal totalAmount=(decimal)addAmount.Invoke(expendInfo,new object[] {amount1, amount2 });
Console.WriteLine("总金额："+totalAmount);

//补充：泛型方法获取与调用
MethodInfo createObj = typeof(GenericMethodClass).GetMethod("CreateObj");//获取方法
MethodInfo createObjNew=createObj.MakeGenericMethod(typeof(IncomeInfo));//转换为泛型方法，传入实际类型对象
IncomeInfo income=  (IncomeInfo)createObjNew.Invoke(null, null);//调用泛型方法，创建一个实例

//获取类型，创建实例
Type incomeType = typeof(IncomeInfo);
//object incomeObj = Activator.CreateInstance(incomeType);
//获取构造函数
//1). 无参构造函数
ConstructorInfo cons0=   incomeType.GetConstructor(new Type[] { });
//调用无参构造函数创建一个默认实例
IncomeInfo income0= (IncomeInfo)cons0.Invoke(null);
//2) 带一个参数的构造函数
ConstructorInfo cons1 = incomeType.GetConstructor(new Type[] { typeof(int)});
//调用带一个参数构造函数创建一个实例
int id = 102;
IncomeInfo income1 = (IncomeInfo)cons1.Invoke(new object[] {id});
//3) 带2个参数的构造函数
ConstructorInfo cons2 = incomeType.GetConstructor(new Type[] { typeof(int),typeof(decimal) });
//调用带2个参数构造函数创建一个实例
int id1 = 103;
decimal amount1 = 300;
IncomeInfo income2= (IncomeInfo)cons2.Invoke(new object[] { id1,amount1 });
//4) 带3个参数的构造函数
ConstructorInfo cons3 = incomeType.GetConstructor(new Type[] { typeof(int),typeof(string), typeof(decimal) });
//调用带3个参数构造函数创建一个实例
int id2 = 104;
decimal amount2 = 100;
IncomeInfo income3 = (IncomeInfo)cons3.Invoke(new object[] { id2,"发奖金", amount2 });

//动态加载程序集
Assembly assModels = null;
//1) Load  传入程序集文件名，不带.dll后缀名  dll文件放入起始位置  .Net8 识别不到程序
//Models项目添加引用进来，这种方式就可以
 assModels = Assembly.Load("Zhaoxi.Models");
//2) LoadFile 传入程序集文件的完整路径（绝对路径）
assModels = Assembly.LoadFile("D:\\xxxxx\\Zhaoxi.Models.dll");
//3)LoadFrom(程序集文件名,带.dll后缀名)
assModels = Assembly.LoadFrom("Zhaoxi.Models.dll");

Type stuType = assModels.GetType("Zhaoxi.Models.Student");
Student stu = (Student)Activator.CreateInstance(stuType);
```
#### 反射的优缺点
优点： 

- 反射提高了程序的灵活性和扩展性。
- 降低耦合性，提高自适应能力。
- 它允许程序创建和控制任何类的对象，无需提前硬编码目标类。

缺点：

- 性能问题：使用反射基本上是一种解释操作，用于字段和方法接入时要远慢于直接代码。因此反射机制主要应用在对灵活性和拓展性要求很高的系统框架上，普通程序不建议使用。
- 使用反射会模糊程序内部逻辑；程序员希望在源代码中看到程序的逻辑，反射却绕过了源代码的技术，因而会带来维护的问题，反射代码比相应的直接代码更复杂。
### 委托
#### 委托的定义与特点
C#中的委托(Delegate)类似于C或C+中的函数指针，是一种引用类型，表示对具有特定参数列表和返回类型的**方法的引用**。
委托经常适用于实现**事件和回调方法**，所有的委托都派生自**System.Delegate**类。
在实例化委托时，可以将**委托的实例**与具有相同参数列表与返回值类型的**方法相关联**，然后就可以通过委托实例来调用方法。
使用委托还可以将**方法作为参数**传递给其他方法。
委托具有以下特点：

- 委托是完全面向对象的，委托是同时封装对象实例和方法，
- 委托允许将方法作为参数进行传递：
- 委托可用于定义回调方法：
- 委托可以将多个方法链接在一起；
- 方法不必与委托类型完全匹配：
- C#2.0版引入了匿名函数的概念，可以将代码块作为参数（而不是单独定义的方法）进行传递。C#3.0引入了Lambda表达式，利用它们可以更简练地编写内联代码块。匿名方法和Lābda表达式都可编译为委托类型，这些功能现在统称为匿名函数。
#### 委托声明与实例化
声明委托需要使用**delegate**关键字，语法如下：
```
delegate 返回值类型 委托名(参数列表...)
delegate int Calculate(int a, int b);
delegate void ShowMsg(string msg);
```
委托可以引用与委托具有**相同签名**的方法，也就是说委托在声明时即**确定了委托可以引用的方法**。
相同签名：方法的**返回值类型、参数类型、参数个数、参数顺序**都完全相同，并不是方法名与委托名相同

实例化

1. 委托声明后，可用**new**关键字来实例化，即创建委托对象，将其与特定的方法关联。
```
delegate int Calculate(int a, int b); //声明一个计算的委托
//提过两个与之对应的方法
public int Add(int a, int b)
{
  return a + b;
}
public void Test(){
  //实例化委托
  Calculate add = new Calculate(Add); //创建委托对象，并与Add关联
  add(10,20); //30
}
```

2. 委托还可以通过将方法签名赋给委托对象
```
Calculate add1 = Add;
add1(20,5); //25
```
#### 多播委托
委托对象可使用"+="运算符合并多个委托。只有相同类型的委托可被合并。使用"="运算符可用于从合并的委托中移除委托。
使用委托的这个特点，可以创建一个委托被调用时要调用的方法列表，这被称为委托的多播(multicasting)。
多播委托应用于：一个动作触发一连串的的操作。
```
//声明
delegate void ShowMsg(string msg);
public static void Show1(string msg)
{
    Console.WriteLine($"show1: {msg}");
}
public static void Show2(string msg)
{
    Console.WriteLine($"show2: {msg}");
}

//使用
ShowMsg msg = Show1;
msg += Show2;
msg("Hello World！");
// show1: Hello World！
// show2: Hello World！
```
