### 微信支付

#### 1 名词解释

微信支付有两种模式：

- 普通商户模式

- 服务商+特约商户模式



#### 2 普通商户模式



#### 3 服务商+特约商户模式

注： 服务商是普通服务商，服务商还有收付通类型

##### 3.1 小程序支付（JavaSDK）

支付资料准备：

- 小程序的AppID和AppSecret
- 商户API证书私钥：[官方文档](https://pay.weixin.qq.com/doc/v3/merchant/4013053053)

- 商户API证书的证书序列号
- APIv3秘钥：[文档](https://pay.weixin.qq.com/doc/v3/merchant/4013053267)
- 微信支付公钥（商户接收APIv3的请求应答、回调时验签使用）
- 微信支付公钥ID（申请支付公钥时获取）

支付流程：

![image-20250808150742751](images/微信支付/image-20250808150742751.png)

###### 3.1.1 Java代码

> [POM依赖](https://github.com/wechatpay-apiv3/wechatpay-java?tab=readme-ov-file)

```xml
<!-- 官方的微信支付 -->
<dependency>
    <groupId>com.github.wechatpay-apiv3</groupId>
    <artifactId>wechatpay-java</artifactId>
    <version>0.2.17</version>
</dependency>
```

> 公共配置属性类

```java
@Data
@Configuration
@ConfigurationProperties(prefix = "wx")
public class WechatPayProperties {
    /** 应用ID */
    private String appId = "wx89dd13b9a9*****";
    /** 小程序密钥 */
    private String secret = "0d883cacfc29acea17b901e2ece*****";
    /** 服务商商户号 */
    private String mchId = "1719******";
    /** 商户API证书序列号 */
    private String mchSerialNo = "41F22582CF54A62BACCE15F2C8*****19BE3816";
    /** 商户APIv3密钥 */
    private String apiKey = "YGmhQdBPnmKUPCcF4afJTdpeNC******";
    /** 商户API私钥文件路径 */
    private String privateKeyPath = "cert/apiclient_key.pem";
    /** 微信支付公钥ID */
    private String publicKeyId = "PUB_KEY_ID_0117193469652025061200442301******";
    /** 微信支付公钥文件路径 */
    private String publicKeyPath = "cert/pub_key.pem";
    /** 回调地址 */
    private String notifyUrl = "http://callback.com";
}
```
> 回调工具类

```java
public enum CallbackUrl {

    /**
     * 支付成功回调地址
     */
    PAYMENT_CALLBACK("/wechat/pay/payNotify"),
    /**
     * 退款回调地址
     */
    REFUND_CALLBACK("/wechat/pay/refundNotify");

    private static String baseUrl;
    private final String path;

    CallbackUrl(String path) {
        this.path = path;
    }

    public String getUrl() {
        if (baseUrl == null) {
            throw new JeecgBootException("CallbackUrl.baseUrl 未初始化");
        }
        return baseUrl + path;
    }
    /**
     * 设置回调基地址
     */
    public static void initBaseUrl(String baseUrl) {
        CallbackUrl.baseUrl = baseUrl.endsWith("/") ? 
            baseUrl.substring(0, baseUrl.length() - 1) : baseUrl;
    }

}
```

> 支付配置类

```java
/**
 * 微信支付配置类
 * 配置微信支付相关服务和解析器
 */
@Getter
@Configuration
@RequiredArgsConstructor
public class WechatPayConfig {
    private final WechatPayProperties wechatPayProperties;
    private Config config;


    /**
     * 初始化微信支付配置
     */
    @PostConstruct
    public void init() {
        // 初始化回调URL基地址
        CallbackUrl.initBaseUrl(wechatPayProperties.getNotifyUrl());
        //初始化微信支付核心配置
        initConfig();
    }

    /**
     * RSAPublicKeyConfig 用于 API 请求加密和验签
     */
    public void initConfig() {
        // 一个商户号只能初始化一个配置，否则会因为重复的下载任务报错
        // RSAPublicKeyConfig 就是公钥验签配置
        try {
            String privateKeyContent = PemFileUtil.readPemFromClasspath(
                    wechatPayProperties.getPrivateKeyPath()
            );
            String publicKeyContent = PemFileUtil.readPemFromClasspath(
                    wechatPayProperties.getPublicKeyPath()
            );

            config = new RSAPublicKeyConfig.Builder()
                    .merchantId(wechatPayProperties.getMchId())
                    .privateKey(privateKeyContent)
                    .publicKey(publicKeyContent)
                    .publicKeyId(wechatPayProperties.getPublicKeyId())
                    .merchantSerialNumber(wechatPayProperties.getMchSerialNo())
                    .apiV3Key(wechatPayProperties.getApiKey())
                    .build();
        } catch (Exception e) {
            throw new JeecgBootException("初始化微信支付配置失败", e);
        }
    }
    /**
     * 支付回调 解密
     */
    @Primary
    @Bean
    public NotificationParser notificationParser() {

        RSAPublicKeyNotificationConfig notificationConfig = null;
        try {
            String publicKeyContent = PemFileUtil.readPemFromClasspath(
                    wechatPayProperties.getPublicKeyPath()
            );
            notificationConfig = new RSAPublicKeyNotificationConfig.Builder()
                    .publicKey(publicKeyContent)
                    .publicKeyId(wechatPayProperties.getPublicKeyId())
                    .apiV3Key(wechatPayProperties.getApiKey())
                    .build();
        } catch (Exception e) {
            throw new JeecgBootException("初始化微信支付回调解密配置失败", e);
        }
        return new NotificationParser(notificationConfig);
    }
    /**
     * JSAPI支付/小程序支付
     * 提供商户在微信客户端内部浏览器网页中使用微信支付收款的能力。（包含小程序）
     * 其他接口的Service也可以在这里注册到容器中（H5Service、NativePayService）
     */
    @Bean
    public JsapiService jsapiService() {
        return new JsapiService.Builder().config(config).build();
    }

    /**  申请退款 */
    @Bean
    public RefundService refundService() {
        return new RefundService.Builder().config(config).build();
    }
}
```

> 工具类

```java
public class WeChatUtil {

    /**
    * 获取支付签名
    */
    public static String getSign(String signatureStr, String privateKeyPath, String merchantSerialNumber) {
        PrivateKey privateKey = PemUtil.loadPrivateKeyFromString(privateKeyPath);
        RSASigner rsaSigner = new RSASigner(merchantSerialNumber, privateKey);
        SignatureResult signatureResult = rsaSigner.sign(signatureStr);
        return signatureResult.getSign();
    }

    /**
     * 构造 RequestParam 回调的时候获取请求头
     */
    public static RequestParam handleNodifyRequestParam(HttpServletRequest request) throws IOException {
        // 请求头Wechatpay-Signature
        String signature = request.getHeader("Wechatpay-Signature");
        // 请求头Wechatpay-nonce
        String nonce = request.getHeader("Wechatpay-Nonce");
        // 请求头Wechatpay-Timestamp
        String timestamp = request.getHeader("Wechatpay-Timestamp");
        // 微信支付证书序列号
        String serial = request.getHeader("Wechatpay-Serial");
        // 构造 RequestParam
        return new RequestParam.Builder()
                .serialNumber(serial)
                .nonce(nonce)
                .signature(signature)
                .timestamp(timestamp)
                .body(getRequestBody(request))
                .build();

    }

    public static String getRequestBody(HttpServletRequest request) throws IOException {
        ServletInputStream stream;
        BufferedReader reader = null;
        StringBuilder sb = new StringBuilder();
        try {
            stream = request.getInputStream();
            // 获取响应
            reader = new BufferedReader(new InputStreamReader(stream));
            String line;
            while ((line = reader.readLine()) != null) {
                sb.append(line);
            }
        } catch (IOException e) {
            throw new IOException("读取返回支付接口数据流出现异常！");
        } finally {
            if (reader != null) {
                reader.close();
            }
        }
        return sb.toString();
    }
}

/**
 * PEM 文件读取工具类，支持从 classpath 加载 .pem 文件并返回其字符串内容
 */
public class PemFileUtil {

    /**
     * 从 classpath 加载 PEM 文件并返回其字符串内容
     * @param classpathPath 例如 "cert/apiclient_key.pem"
     * @return PEM 文件的字符串内容
     * @throws RuntimeException 加载失败会抛出异常
     */
    public static String readPemFromClasspath(String classpathPath) {
        InputStream is = null;
        BufferedReader reader = null;
        try {
            is = Thread.currentThread().getContextClassLoader().getResourceAsStream(classpathPath);
            if (is == null) {
                throw new IllegalArgumentException("无法从 classpath 加载文件: " + classpathPath);
            }

            reader = new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8));
            StringBuilder sb = new StringBuilder();
            String line;

            while ((line = reader.readLine()) != null) {
                sb.append(line).append("\n");
            }

            return sb.toString();
        } catch (IOException e) {
            throw new RuntimeException("读取 PEM 文件失败: " + classpathPath, e);
        } finally {
            try {
                if (reader != null) reader.close();
                if (is != null) is.close();
            } catch (IOException ignore) {
            }
        }
    }
}
```





> 下单方法：[下单API参数说明](https://pay.weixin.qq.com/doc/v3/partner/4012759974)

```java
@Override
public WechatPayDTO jsPay(WechatPayReqParam param) {
    if (param == null) {
        throw new JeecgBootException("支付参数不能为空");
    }
    // 调用下单方法，得到应答
    try {
        // 业务系统根据参数创建订单
        PaymentInfo paymentInfo = buildPaymentInfo(param);
        // 构建预支付请求
        PrepayRequest prepayRequest = buildPrepayRequest(param, paymentInfo);
        prepayRequest.getPayer().setSpOpenid(param.getMiniOpenid());
        // 调用下单api
        PrepayResponse prepayResponse = jsapiService.prepay(prepayRequest);
        // 将 WechatPayDto 中的值返回小程序就可以唤起支付页面 也就是输入密码页面
        return buildWechatPayDTO(prepayResponse, paymentInfo);
    } catch (HttpException e) { 
        // 发送HTTP请求失败
        throw new JeecgBootException("发送HTTP请求失败");
    } catch (ServiceException e) {
        // 服务返回状态小于200或大于等于300，例如500
        throw new JeecgBootException("服务返回状态异常");
    } catch (MalformedMessageException e) {
        // 服务返回成功，返回体类型不合法，或者解析返回体失败
        throw new JeecgBootException("解析返回体失败");
    } catch (Exception e) {
        throw new JeecgBootException("微信支付预下单异常");
    }
}

/**
* 构建支付凭证DTO
*/
private WechatPayDTO buildWechatPayDTO(PrepayResponse prepayResponse, PaymentInfo paymentInfo) {
    WechatPayDTO dto = new WechatPayDTO();
    // 业务系统订单id
    dto.setOrderId(paymentInfo.getOrderId());
    // 小程序的appId
    dto.setAppid(wechatPayProperties.getAppId());
    dto.setTimeStamp(String.valueOf(System.currentTimeMillis() / 1000));
    dto.setNonceStr(NonceUtil.createNonce(32));
    dto.setPrepayId("prepay_id=" + prepayResponse.getPrepayId());
    dto.setSignType("RSA");
    // 生成支付签名
    String signContent = Stream.of(
        dto.getAppid(),
        dto.getTimeStamp(),
        dto.getNonceStr(),
        dto.getPrepayId()
    ).collect(Collectors.joining("\n", "", "\n"));

    String privateKey = PemFileUtil.readPemFromClasspath(wechatPayProperties.getPrivateKeyPath());
    dto.setPaySign(WeChatUtil.getSign(
        signContent,
        privateKey,
        wechatPayProperties.getMchSerialNo()
    ));
    return dto;
}
```

> 支付成功回调方法

```java
@Override
    public Map<String,String> payNotify(HttpServletRequest request, HttpServletResponse response) {
        Transaction transaction;
        HashMap<String, String> resultMap = new HashMap<>(2);
        try {
            //解析微信回调参数
            transaction = notificationParser.parse(WeChatUtil.handleNodifyRequestParam(request), Transaction.class);
            if (transaction.getTradeState() != Transaction.TradeStateEnum.SUCCESS) {
                log.warn("交易未成功: 当前状态={}", transaction.getTradeState());
                resultMap.put("code", "FAIL");
                resultMap.put("message", "交易未成功");
                return resultMap;
            }
            //获取并验证订单信息
            String outTradeNo = transaction.getOutTradeNo();
            log.info("处理支付回调: 订单号={}, 交易信息={}", outTradeNo, JSON.toJSONString(transaction));
            //查询支付记录
            LambdaQueryWrapper<PaymentInfo> queryWrapper = new LambdaQueryWrapper<>();
            queryWrapper.eq(PaymentInfo::getOrderId, outTradeNo);
            PaymentInfo paymentInfo = paymentInfoMapper.selectOne(queryWrapper);
            if (paymentInfo == null) {
                log.error("订单不存在: orderId={}", outTradeNo);
                resultMap.put("code", "FAIL");
                resultMap.put("message", "订单不存在");
                return resultMap;
            }
            //幂等性检查（防止重复处理）
            if (paymentInfo.getPayStatus() != PaymentStatusEnum.UNPAID.getPayStatus()) {
                log.warn("订单已处理: orderId={}, 当前状态={}", outTradeNo, paymentInfo.getPayStatus());
                resultMap.put("code", "SUCCESS");
                resultMap.put("message", "订单已处理");
                return resultMap;
            }
            //金额一致性校验
            int callbackAmount = transaction.getAmount().getTotal();
            if (callbackAmount != paymentInfo.getPayTotal()) {
                log.error("金额不一致: 订单金额={}, 回调金额={}", paymentInfo.getPayTotal(), callbackAmount);
                resultMap.put("code", "FAIL");
                resultMap.put("message", "金额不一致");
                return resultMap;
            }
            //更新支付记录
            updatePaymentInfo(paymentInfo, transaction);
            paymentInfoMapper.updateById(paymentInfo);
            //触发服务号推送信息给用户
            //根据小程序的openid查询服务号的openid
            UserWechat userWechat =
                    userWechatService.getUserWechat(UserWechat.builder().build()
                            .setMiniOpenid(transaction.getPayer().getSpOpenid()));
            if (userWechat != null && CharSequenceUtil.isNotBlank(userWechat.getMpOpenid())) {
                TemplateDataDTO templateDataDTO = new TemplateDataDTO();
                templateDataDTO.setOpenId(userWechat.getMpOpenid());
                templateDataDTO.setOrderId(paymentInfo.getOrderId());
                templateDataDTO.setAmount(paymentInfo.getPayTotal());
                templateDataDTO.setPayTime(paymentInfo.getPayTime());
                templateDataDTO.setPayType(Integer.valueOf(paymentInfo.getReason()));
                Merchant merchant = merchantService.getById(paymentInfo.getMerchantId());
                templateDataDTO.setBusinessName(merchant.getName());
                wechatMpService.sendTemplateMessage(templateDataDTO);
            }

            //返回给微信的成功相应
            resultMap.put("code", "SUCCESS");
            resultMap.put("message", "处理成功");
            return resultMap;
        } catch (ValidationException | IOException e) {
            // 签名验证失败，返回 401 UNAUTHORIZED 状态码
            String errorMsg = String.format("处理回调异常: %s", e.getMessage());
            log.error(errorMsg, e);
            resultMap.put("code", "FAIL");
            resultMap.put("message", "处理失败");
            return resultMap;
        }
    }
```








小程序支付demo

- 小程序下单
- 小程序支付
- 支付回调
- 退款
- 退款回调
- 根据支付订单id查询微信订单记录



##### 3.2 特约商户进件





#### 商户注销

> 注：特约商户也算是属于特约商户
>
> 特约商户注销后，服务商的特约商户列表中注销的特约商户仍然存在

商户注销链接：https://kf.qq.com/touch/sappfaq/221220E32IBV221220rEnqI7.html?scene_id=kf594&platform=14

目前服务商还不支持主动注销
